package componentparser

import (
	"go/ast"
	"go/token"
	"strings"
	"unicode"
)

/*
Data corresponding to a particular struct representing a component. These
structs are identified by the components package by the use of comment strings
defined inside of the struct.
*/
type StructData struct {
	Name       string // The text string representing the component as it was found
	Generic    Fields // Represent any generic types for the struct
	StructFile string // The file the struct was found in

	PackageName   string // The name of the package the struct resides in
	PackageFolder string // The enclosing folder of the struct file

	ConvertVar      string // The string that represents the reciever variable in the convert function
	ConvertFunction string // Full text of the params.Convert function

	ScopedNames map[string]bool // List of names that appear in the package

	/*
		All the imports required for all the files associated with the
		component. This includes all methods as well.
	*/
	Imports map[string]bool

	Fields  Fields       // All the fields for this component
	Methods []MethodData // All the public methods for this component

	// Generate flags
	Options StructOptions
}

func (s *StructData) ID() string {
	return s.PackageFolder + "::" + s.Name
}

/*
Flags for the components generate function. These fields are set via a struct
*/
type StructOptions struct {
	Generate bool // Whether or not a "generate:component" tag was found in the comments of this struct

	InterfaceName    string // Name of the interface once generated
	InterfaceFolder  string // Folder for the exported interface to go
	InterfacePackage string // Name of the package for the generated interface.
	InterfaceFile    string // File Name for the generated interface to go

	MockFolder  string // Name of the generated mockery folder
	MockPackage string // Name of the generated mockery package
	MockFile    string // Location of the generated mockery files

	SkipTestFile bool // True if the test file should be created.

	/*
		Whether or not to generate the tests file for this struct in the same
		package or as a "blackbox" with the "_test" extension. If enabled, the
		folder variable will describe where the blackbox tests go.
	*/
	Blackbox       bool
	BlackboxFolder string

	// The config to use for the mockery generation
	Config string

	// Whether or not to create shortcut expecters for each mocked subcomponent
	Expecters []string
}

// Only call when parsing
func (p *Parser) CreateBaseStructData(name string) *StructData {
	structData := &StructData{
		Name:          name,
		Generic:       Fields{},
		PackageName:   p.PackageName,
		PackageFolder: p.PackageFolder,

		ScopedNames: p.ScopedNames,

		Methods: []MethodData{},
		Options: StructOptions{
			Expecters: []string{},
		},
	}

	if _, ok := p.Structs[structData.ID()]; !ok {
		p.Structs[structData.ID()] = structData
	}

	return p.Structs[structData.ID()]
}

/*
Parse a GenDecl node and add the data to the Parser. The two node types that are
relevant are the imports and the structs.
*/
func (p *Parser) ParseGenDecl(node *ast.GenDecl) {

	/*
		Import case. Make sure the import is captured and added to the
		parser.PackageImports attribute so that generateed files can include
		all the needed imports.
	*/
	if node.Tok == token.IMPORT {
		_, ok := p.PackageImports[p.PackageName]
		if !ok {
			p.PackageImports[p.PackageName] = map[string]bool{}
		}

		for _, importNode := range FindChildNodes[*ast.ImportSpec](node) {
			p.PackageImports[p.PackageName][p.FileString.Extract(importNode)] = true
		}
	}

	// Don't process anything that isn't a struct. We don't care about them
	if node.Tok != token.TYPE {
		return
	}

	// Grab the type node so we can grab the name
	typeNode := FindChildNode[*ast.TypeSpec](node)

	structNodes := FindChildNodes[*ast.StructType](node)
	if len(structNodes) == 0 {
		return
	}
	structNode := structNodes[0]

	// Start creating the struct object and then parse it with the given node
	structData := p.CreateBaseStructData(typeNode.Name.Name)
	p.PopulateStructData(structData, structNode)

	// Determine if this is a generic type struct
	generics := string(p.FileString[typeNode.Name.End()-1 : structNode.Pos()-1])
	startIndex, endIndex := strings.Index(generics, "["), strings.Index(generics, "]")
	if startIndex != -1 && endIndex != -1 {
		generics = generics[startIndex+1 : endIndex]
		structData.Generic = ConvertTypeString(generics)
	}

}

/*
Function to populate the base struct data
*/
func (p *Parser) PopulateStructData(structData *StructData, node *ast.StructType) {

	/*
		Determine if there is a tag specifying that this struct is meant to be
		generated by the components method. If not, we just skip it completely.
	*/

	structString := p.FileString.Extract(node)
	options := extractOptions(structString)

	for option, value := range options {
		switch option {
		case "generate":
			structData.Options.Generate = (value == "components")
		case "interfaceName":
			structData.Options.InterfaceName = value
		case "interfaceFolder":
			structData.Options.InterfaceFolder = value
		case "interfaceFile":
			structData.Options.InterfaceFile = value
		case "config":
			structData.Options.Config = value
		case "mockFolder":
			structData.Options.MockFolder = value
		case "mockFile":
			structData.Options.MockFile = value
		case "blackbox":
			structData.Options.Blackbox = (value == "true")
		case "blackboxFolder":
			structData.Options.BlackboxFolder = value
		case "skipTestFile":
			structData.Options.SkipTestFile = (value == "true")
		case "expecters":
			structData.Options.Expecters = strings.Split(value, ",")
		default:
			panic("invalid option " + option + " in struct " + p.File + "::" + structData.Name)
		}
	}

	if !structData.Options.Generate {
		return
	}

	// Loop through all the fields of the node and add them to the structData
	structData.Fields = ConvertASTFieldList(p.FileString, node.Fields)
	structData.StructFile = p.File

}

/*
Add method data to a struct. Also handles reading the params convert function
*/
func (p *Parser) ParseFuncDecl(node *ast.FuncDecl) {

	// Only grab methods which are exported.
	if !unicode.IsUpper(rune(node.Name.Name[0])) {
		return
	}

	// The recv parameter is also stored as a field. Extract it from the node
	if node.Recv == nil {
		return
	}
	recv := ConvertASTFieldList(p.FileString, node.Recv)[0]

	/*
		For the params function declaration specifically, we need to determine
		which component this is for so we can update the Convert function.
	*/
	if len(recv.Type) >= 7 && recv.Type[:7] == "*Params" {

		// Make sure this is the convert function
		if node.Name.Name != "Convert" {
			return
		}

		// Make sure the return value is exactly one value
		output := ConvertASTFieldList(p.FileString, node.Type.Results)
		if len(output) != 1 {
			return
		}

		/*
			Grab the struct name and make sure the params haven't already
			returned this component type before. We need this to be unambiguous
		*/

		/*
			The first character should be a "*". If it isn't, something is wrong
			and the user should change the convert function.
		*/
		structName := CleanType(output[0].Type)
		structData := p.CreateBaseStructData(structName)
		if structData.ConvertFunction != "" {
			panic("more than one *Params method that returns matching component " + structName + ".")
		}

		structData.ConvertVar = recv.Name
		structData.ConvertFunction = p.FileString.Extract(node.Body)
		return
	}

	// If not a params function, we grab the struct data
	structData := p.CreateBaseStructData(CleanType(recv.Type))
	args := Fields{}
	if node.Type.Params != nil {
		args = ConvertASTFieldList(p.FileString, node.Type.Params)
	}

	returns := Fields{}
	if node.Type.Results != nil {
		returns = ConvertASTFieldList(p.FileString, node.Type.Results)
	}

	structData.Methods = append(structData.Methods, MethodData{
		Name:    node.Name.Name,
		Recv:    recv,
		Args:    args,
		Returns: returns,
	})

}

package generate

import (
	"fmt"
	"os"
	"strings"

	"github.com/flywingedai/components/generate/componentparser"
	"github.com/flywingedai/components/generate/helpers"
	"github.com/flywingedai/components/generate/templates"
)

func generateTest(structData *componentparser.StructData) {
	genericShort, genericLong := structData.Generic.Generic(false)

	/*
		The main test file for the component is just the name of the file the
		component struct was found in with the _test extenstion.
	*/
	fileName := strings.ReplaceAll(structData.StructFile, ".go", "_test.go")

	// Determine the package name for the tests. Add _test if "blackbox"
	packageName := structData.PackageName
	if structData.Options.Blackbox {
		packageName += "_test"
	}

	// Determine how to reference Params
	paramsPrefix := ""
	if structData.Options.Blackbox {
		paramsPrefix += structData.PackageName + "."
	}
	paramsString := paramsPrefix + "Params"

	/*
		If the file Does not exist, we need to add the InitParams function to
		the file first. We do this as we want that function to be ABOVE the
		autogenerated code so it can be easily updated by users.
	*/
	if _, err := os.Stat(fileName); os.IsNotExist(err) {

		// We started writing the new file with the package name imported
		fileString := "package " + packageName + "\n"

		/*
			We add to the base file the initParams function with the correct
			typing handed via the replacement.
		*/
		fileString += templates.BulkReplace(templates.InitParams, map[string]string{
			"GenericShort": genericShort,
			"GenericLong":  genericLong,
			"ParamsPath":   paramsString,
		})

		/*
			Simply write the file. We don't need the helper as we don't want to
			add the auto-generated key until after the initPrams function
		*/
		err = os.WriteFile(fileName, []byte(fileString), 0777)
		if err != nil {
			panic(err)
		}
	}

	/*
		Now we create the mock struct. The mock struct is an exact replica of
		the base component struct except we update all the fields tagged with
		mockable values accordingly
	*/
	mockString := ""
	mockString += fmt.Sprintf("type mocks%s struct{\n", genericLong)
	for _, f := range structData.Fields {
		if f.MockPkg == "" {
			mockString += fmt.Sprintf("\t%s %s\n", f.Name, f.Type)
			continue
		}
		mockString += fmt.Sprintf("\t%s *%s\n", f.Name, f.MockPkg+"."+f.MockType)
	}
	mockString += "}\n\n"

	/*
		Now we create the convert function which turns the params into mocks.
		We just copy the exact Params.Convert() function with changes made to
		facilitate the new fields.
	*/
	function := structData.ConvertFunction
	function = strings.ReplaceAll(function, "&"+structData.Name, "&mocks")

	// We need to handle replacements for each field present in the data
	for _, f := range structData.Fields {
		if f.MockPkg == "" {
			continue
		}

		// Replace all the reciever values with the new values
		recv := structData.ConvertVar + "."

		// Determine how to cast to the correct type
		cast := "*" + fmt.Sprintf("%s.%s", f.MockPkg, f.MockType)

		/*
			Need upper case version of the name as that should be how the the
			params store their attributes.
		*/
		upper := helpers.ToTitle(f.Name)
		function = strings.Replace(function, recv+upper, recv+upper+".("+cast+")", 1)
	}
	mockString += fmt.Sprintf("func convert%s(%s %s) *mocks%s %s\n\n", genericLong, structData.ConvertVar, paramsString+genericShort, genericShort, function)

	/*
		Now we create the bindings for each of the mockable components which
		allow us to quickly generated mock functions for them during testing.
	*/

	// Start with creating each of the subcomponent mocks
	mockComponents := ""
	for _, f := range structData.Fields {
		if f.MockPkg == "" {
			continue
		}

		mockComponents += fmt.Sprintf("params.%s = %s.%s(t)\n", helpers.ToTitle(f.Name), f.MockPkg, f.MockNew)

	}

	// Then we handle the build function mocks
	componentPackage := ""
	interfacePackage := ""
	if structData.Options.Blackbox {
		componentPackage = structData.PackageName + "."
		interfacePackage = structData.Options.InterfacePackage + "."
	}
	mockString += templates.BulkReplace(templates.BuildMocks, map[string]string{
		"GenericShort":     genericShort,
		"GenericLong":      genericLong,
		"InterfaceName":    structData.Options.InterfaceName,
		"InterfacePackage": interfacePackage,
		"ComponentPackage": componentPackage,
		"MockFields":       mockComponents,
	})

	// Finally, we replace all the component mock generation functions
	for _, f := range structData.Fields {
		if f.MockPkg == "" {
			continue
		}

		found := len(structData.Options.Expecters) == 0
		for _, expecter := range structData.Options.Expecters {
			if expecter == f.Name {
				found = true
			}
		}

		if !found {
			continue
		}

		// Determine if the mock type has any generic type attached to it
		genericShort, genericShortAppend := "", ""
		startIndex, endIndex := strings.Index(f.MockType, "["), strings.Index(f.MockType, "]")
		if startIndex != -1 && endIndex != -1 {
			generics := componentparser.ConvertTypeString(f.MockType[startIndex+1 : endIndex])
			genericShort, _ = generics.Generic(false)
			genericShortAppend, _ = generics.Generic(true)
			f.MockType = f.MockType[:startIndex]
		}

		mockString += templates.BulkReplace(templates.GetMockField, map[string]string{
			"GenericShort":       genericShort,
			"GenericShortAppend": genericShortAppend,
			"FieldName":          f.Name,
			"MockPackage":        f.MockPkg,
			"MockType":           f.MockType,
		})
	}

	helpers.WriteToFile(fileName, mockString, structData.Imports, packageName)

}

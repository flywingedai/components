package helpers

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path"
	"strings"
)

const generatedDisclaimer = "// Code below was generated by components. DO NOT EDIT.\n"
const generatedVersion = "// Component version: v1.2.0\n"

// Map of all the files which have been regenerated already during this call
var regeneratedFiles = map[string]bool{}

func WriteToFile(
	fileName string, // Name of the file we're writing to
	code string, // The code to add to the file
	imports map[string]bool, // All the imports to include during this write
	packageName string, // The package name. Needed in case this call would generate a new file
) {

	// Read try to read in the file.
	fileData, err := os.ReadFile(fileName)
	fileExisted := !errors.Is(err, os.ErrNotExist)

	// If the file didn't exist. We wand to create the file first
	if !fileExisted {

		// If the file doesn't exist, we make everything first
		err = os.MkdirAll(path.Dir(fileName), 0777)
		if err != nil {
			panic(err)
		}

		// Since we just made this file, it has no file data.
		fileData = []byte{}

	} else if err != nil {
		// If there were any errors, simply panic
		panic(err)
	}

	// It's easier to work with a string of the file than a bunch of bytes
	fileString := string(fileData)

	/*
		Clear out the part of the file after the disclaimer if this file hase
		not been regenerated during this call yet
	*/
	if !regeneratedFiles[fileName] {
		regeneratedFiles[fileName] = true

		/*
			If there is a generated disclaimer in the file, we cut off
			everything after it. If there is no disclaimer, just add a newLine
			to ensure there is a good spacing before adding the disclaimer.
		*/
		index := strings.Index(fileString, generatedDisclaimer)
		if index != -1 {
			fileString = fileString[:index+len(generatedDisclaimer)] + generatedVersion
		} else {
			fileString += "\n" + generatedDisclaimer + generatedVersion
		}

	}

	// Add imports statements below the package if relevant
	packageID := "package " + packageName + "\n"
	index := strings.Index(fileString, packageID)
	if index >= 0 {
		if len(imports) > 0 {
			cutIndex := index + len(packageID)
			importString := "import (\n"
			for importData := range imports {
				importString += "\t\"" + importData + "\"\n"
			}
			importString += "\n)"
			fileString = fileString[:cutIndex] + importString + fileString[cutIndex:]
		}
	} else {
		fileString += fmt.Sprintf("package %s\n", packageName)
	}

	// Add the code data to the file string
	fileString += code

	// Try and write the updated file string to the file
	err = os.WriteFile(fileName, []byte(fileString), 0777)
	if err != nil {
		panic(err)
	}

	/*
		Run the goimports command on the file. This will automatically format
		the imports and other basic file parameters.
	*/
	cmd := exec.Command("goimports", "-w", fileName)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	err = cmd.Run()
	if err != nil {
		panic(err)
	}

}
